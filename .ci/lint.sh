#!/bin/sh

FAILED=0
STEP_MESSAGES=

fail() {
    FAILED=$((FAILED + 1))
    STEP_MESSAGES="${STEP_MESSAGES}  Step \"$1\" failed with code $2
"
}

generate_cmake() {
    mkdir -p build
    BUILD_DIR="$(mktemp -dp build "$1.XXXXXXXXX")"
    trap 'rm -rf "'"$BUILD_DIR"'"' EXIT

    cmake --fresh -G Ninja -B "$BUILD_DIR" . \
        -D CMAKE_BUILD_TYPE=Debug \
        -D CMAKE_EXPORT_COMPILE_COMMANDS=ON \
        -D CMAKE_C_COMPILER=clang \
        -D CMAKE_CXX_COMPILER=clang++ \
        -D MAGNESIA_WARNINGS_AS_ERRORS=ON \
        -D MAGNESIA_BUILD_DOCS=OFF \
        -D BUILD_TESTING=ON

    # NOTE: open62541 generates headers during build. This means we have to build open62541 for clang-tidy to find all
    # includes if using CMake's FetchContent to build it. This is not an issue if the library is provided by the system,
    # so ignore if the target doesn't exist.
    cmake --build "$BUILD_DIR" --target libopen62541.a || true
}

run_cmake_format() {
    find . -path ./build -prune -o \( -name 'CMakeLists.txt' -o -name '*.cmake' \) -print0 \
        | xargs -0 cmake-format --check || fail cmake-format $?
}

run_clang_format() {
    find src test -name '*.[ch]pp' -print0 | xargs -0 clang-format -Werror --dry-run --verbose || fail clang-format $?
}

run_clang_tidy() {
    generate_cmake clang-tidy

    # TODO: use run-clang-tidy -source-filter
    find src test -name '*.cpp' -print0 \
        | xargs -0 run-clang-tidy \
            -warnings-as-errors='*' \
            -use-color \
            -header-filter='.*' \
            -p "$BUILD_DIR" \
        || fail clang-tidy $?

    # Manually run include-cleaner on header files, see https://github.com/llvm/llvm-project/issues/67550 for details
    # why this is necessary.
    find src test -name '*.hpp' -print0 \
        | parallel -v0 clang-tidy \
            --warnings-as-errors='*' \
            --use-color \
            --header-filter='.*' \
            --checks='-*,misc-include-cleaner' \
            -p="$BUILD_DIR" \
        || fail clang-tidy-headers $?
}

run_codespell() {
    codespell || fail codespell $?
}

run_qt_headers() {
    find src test -name '*.[ch]pp' -print0 \
        | xargs -0 grep -nE '#include <q.*\.h>' | grep -vF '#include <qtmetamacros.h>' && fail "qt_headers" $?
    true
}

run_shellcheck() {
    find . -path ./build -prune -o -name '*.sh' -print0 | xargs -0 shellcheck || fail shellcheck $?
}

run_shfmt() {
    find . -path ./build -prune -o -name '*.sh' -print0 | xargs -0 shfmt \
        --indent 4 \
        --space-redirects \
        --case-indent \
        --binary-next-line \
        --diff \
        || fail shfmt $?
}

run_cppcheck() {
    generate_cmake cppcheck
    # cppcheck complains if the autogenerated files are missing
    cmake --build "$BUILD_DIR" --target autogen magnesia_resources

    mkdir "$BUILD_DIR/cppcheck"
    cppcheck \
        --error-exitcode=2 \
        --cppcheck-build-dir="$BUILD_DIR/cppcheck" \
        --project="$BUILD_DIR/compile_commands.json" \
        -i build `# ignore generated code` \
        --library=qt \
        -D Q_DISABLE_COPY_MOVE `# missing from qt.cfg` \
        --library=googletest \
        --check-level=exhaustive \
        --enable=all \
        --disable=unusedFunction \
        --suppress=ignoredReturnErrorCode \
        --suppress=missingIncludeSystem \
        --inline-suppr \
        --force \
        || fail cppcheck $?
}

fast() {
    run_cmake_format
    run_clang_format
    run_codespell
    run_qt_headers
    run_shellcheck
    run_shfmt
}

slow() {
    run_cppcheck
    run_clang_tidy
}

main() {
    set -xeu

    if [ $# -ge 1 ]; then
        if [ "$1" = "fast" ]; then
            fast
        else
            "run_$(printf '%s' "$1" | tr '-' '_')"
        fi
    else
        fast
        slow
    fi

    if [ $FAILED -eq 0 ]; then
        printf "\nSUMMARY: All jobs succesfull\n"
    else
        printf "\nSUMMARY (%d %s failed):\n%s" $FAILED "job$([ $FAILED -ne 1 ] && printf s)" "$STEP_MESSAGES"
    fi
    return $FAILED
}

main "$@"
